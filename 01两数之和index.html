<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>

<script>
    /**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */


// 1.思路:利用map存储出现的数字和index对应关系  
// targetNum为满足的目标元素 prevNums 存储出现过的数字，和对应的索引  
//  prevNums[targetNum]为目标元素的索引  
const twoSum = (nums, target) => {
  const prevNums = {};                    // 存储出现过的数字，和对应的索引               

  for (let i = 0; i < nums.length; i++) { // 遍历元素   
    const curNum = nums[i];               // 当前元素   
    const targetNum = target - curNum;    // 满足要求的目标元素   
    const targetNumIndex = prevNums[targetNum]; //难点： 在prevNums中获取目标元素的索引  
    console.log(prevNums[targetNum]);
    
    if (targetNumIndex !== undefined) {   // 如果存在，直接返回 [目标元素的索引,当前索引]
      return [targetNumIndex, i];
    } else {                              // 如果不存在，说明之前没出现过目标元素
      prevNums[curNum] = i;               // 存入当前的元素和对应的索引
    }
  }
}


let result=twoSum([2,4,3],7);

console.log(result);
//2. 暴力法 
var twoSum = function(nums, target) {
    let arrIndex=[];
    for(var i=0;i<nums.length;i++){
        for(var j=i+1;j<nums.length-1;j++){
            if(target==nums[i]+nums[j]){
                arrIndex.push(i,j);
                return arrIndex; 
            }
        }
    }
};


let result=twoSum([3,2,4],6);
console.log(result);


</script>
</html>